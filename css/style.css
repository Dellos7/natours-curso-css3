/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

/* Selector universal, se aplica a todos los elementos */
*,
*::after,
*::before {
    margin: 0;
    padding: 0;
    /* Esta propiedad no se hereda, por lo que queremos que para todos los elementos
        se herede. Se heredará por tanto (en este caso) del elemento 'body', donde sí
        hemos especificado un valor */
    box-sizing: inherit;
}

/* Aquí se definen los valores del 'root', es decir que los 'rem'
    se aplicarán en base al valor del font-size del elemento 'html' */
html {
    
    /*font-size: 10px;*/
    /* Queremos utilizar 10px 'por defecto' como font-size porque estamos utilizando
    los 'rem' en toda la página. Pero a la vez no queremos sobreescribir el font-size
    si el usuario lo cambia en las preferencias del navegador. Es por ello que dividimos
    10/16 = 0.625, y ese es el porcentaje que utilizaremos del font-size definido por el usuario
    como el font-size base para hacer los cálculos con los 'rem' */
    font-size: 62.5%;
}

/* Todo lo que se incluye en el body se hereda por el resto de elementos */
body {
    font-family: "Lato", sans-serif;
    font-weight: 400;
    /*font-size: 16px;*/
    line-height: 1.7;
    color: #777;
    padding: 3rem; /* El padding no se hereda */
    /* El width y height de un elemento incluye tanto el tamaño del borde 
    como del padding */
    box-sizing: border-box;
}

.header {
    height: 95vh; /* 95% del view-port */
    background-image: linear-gradient(
        to right bottom, 
        rgba(126, 213, 111, 0.8), 
        rgba(40, 180, 133, 0.8)), 
    url( ../img/hero.jpg );
    background-size: cover; /* Cubre todo el elemento en el que se encuentra */
    background-position: top; /* No se recortará la imagen por la parte superior al redimensionar */
    /* Recorta la imagen, crea un polígono donde todo lo que esté fuera no se verá */
    clip-path: polygon( 0 0, 100% 0, 100% 75vh, 0 100% );
    position: relative;
}

.header__logo-box {
    position: absolute;
    top: 4rem;
    left: 4rem;
    animation: moveInDeep 1s;
    animation-delay: 0.8s;
    animation-fill-mode: backwards;
}

.header__logo-box--anim {
    animation: moveInDeepAfter 1.5s;
    animation-delay: 0.8s;
    animation-fill-mode: backwards;
}

.header__logo {
    height: 3.5rem;
}

.header__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    /* Se mueve -50% del tamaño del elemento, tanto en altura como en anchura */
    transform: translate(-50%, -50%);
    text-align: center;
}

.heading-primary {
    color: #fff;
    text-transform: uppercase;
    /* Arregla un bug en las animaciones que hace que se muevan un poco hacia arriba */
    backface-visibility: hidden;
    margin-bottom: 6rem;
}

.heading-primary--main {
    /* Al ser un span, es un elemento 'inline'. Lo ponemos 'block' 
    para que ocupe todo el ancho, y se comporte como un bloque */
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation-name: moveInLeft;
    animation-duration: 1s;
    /* La animación irá más lenta al final */
    animation-timing-function: ease-out;
}

.heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out;
}

/**
* Animación que hace que el texto se mueva desde la izquierda
* siendo invisible al principio
**/
@keyframes moveInLeft {
    0% {
        opacity: 0;
        transform: translateX(-10rem);
    }

    80% {
        transform: translateX(1rem);
    }

    100% {
        opacity: 1;
        transform: translateX(0);
    }
}

/**
* Animación que hace que el texto se mueva desde la derecha
* siendo invisible al principio
**/
@keyframes moveInRight {
    0% {
        opacity: 0;
        transform: translateX(10rem);
    }

    80% {
        transform: translateX(-1rem);
    }

    100% {
        opacity: 1;
        transform: translateX(0);
    }
}

@keyframes moveInBottom {
    0% {
        opacity: 0;
        transform: translateY(3rem);
    }

    100% {
        opacity: 1;
        transform: translateY(0);
    }
}

/* Animación para hacer grande la imagen */
@keyframes moveInDeep {
    0% {
        opacity: 0;
        transform: scale(0);
    }

    100% {
        opacity: 1;
        transform: scale(1);
    }
}

/* Animación para hacer grande la imagen, y cuando llegue a su tamaño normal
    incrementarlo y hacer que desaparezca */
@keyframes moveInDeepAfter {
    0% {
        opacity: 0;
        transform: scale(0);
    }

    50% {
        opacity: 1;
        transform: scale(1);
    }

    100% {
        opacity: 0;
        transform: scale(2);
    }
}

  .btn:link,
  .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    /* Por defecto es inline, por lo que ocupa espacio de otros elementos
        inline-block hace que tenga su propio espacio en la pagina*/
    display: inline-block;
    border-radius: 10rem;
    /* Habilita todas las propiedades de animación (transform, etc) y les dice cuanto deben durar 
        Esto hace que el transform del hover y el active duren lo que se indica aquí*/
    transition: all .2s;
    position: relative;
    font-size: 1.6rem;
  }

  .btn:hover {
      transform: translateY(-3px);
      /* La sombra va 10px hacia abajo, tiene 20px de blur (nublado)*/
      box-shadow: 0 1rem 2rem rgba(0, 0, 0, .2);
  }

  /* Cuando hacemos click */
  .btn:active {
    transform: translateY(-1px);
    box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .2);
  }

  .btn--white {
      background-color: #fff;
      color: #777;
  }

  /* Permite crear un elemento después del elemento actual,
     pero se trata como si fuera un hijo.
     Creamos un elemento que sea igual que el botón actual,
     pero lo ponemos detrás */
  .btn::after {
      border-radius: 10rem;
      content: "";
      display: inline-block;
      height: 100%;
      width: 100%;
      position: absolute;
      top: 0;
      left: 0;
      z-index: -1;
      /* Habilitamos las transiciones para este elemento */
      transition: all .4s;
  }

  .btn--white::after {
    background-color: #fff;
  }

  /* Cuando hagamos hover sobre el botón, queremos que se "estilice"
     el elemento 'after'*/
  .btn:hover::after {
      /* Lo hacemos más grande y lo hacemos invisible */
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0;
  }

  .btn--animated {
    animation: moveInBottom .5s ease-out;
    animation-delay: .75s;
    /* Indica que los estilos en el 0% de la animación se deben aplicar antes de aplicar el delay */
    animation-fill-mode: backwards;
  }